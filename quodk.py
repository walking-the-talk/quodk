# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QuODK
                                 A QGIS plugin
 A link between ODK Central data and QGIS
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-03-30
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Walking-the-Talk
        email                : chris.york@walking-the-talk.co.uk
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QVariant
from qgis.PyQt.QtGui import *# using QIcon, QImage, QPixmap
from qgis.PyQt.QtWidgets import QAction, QComboBox, QFileDialog,  QLabel,  QTableWidget, QTableWidgetItem
from qgis.core import * # using QgsVectorLayer,QgsFeature

from math import isnan
import os
import os.path
import pandas as pd
# Initialize Qt resources from file resources.py
from .resources import *

# Import the code for the dialog
from .quodk_dialog import QuODKDialog



import requests
import json
from urllib.parse import urlparse
from collections.abc import Mapping
from functools import reduce
from datetime import datetime, timedelta
import webbrowser

import shutil


class QuODK:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'QuODK_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&QuODK')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('QuODK', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/quodk/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'QuODK'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&QuODK'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            #self.first_start = False
            self.dlg = QuODKDialog()

        #set default date range as today (24 hour period!)
        self.dlg.DateStart.setDate(datetime.now())
        self.dlg.DateEnd.setDate(datetime.now())
        self.dlg.DateStart.dateChanged.connect(self.onDateChanged)
        self.dlg.DateEnd.dateChanged.connect(self.onDateChanged)
        self.dlg.ODK_connect.clicked.connect(self.connectODK)
        self.dlg.ODK_connect_2.clicked.connect(self.connectODK)
        self.dlg.projectID.activated.connect(self.list_forms)
        self.dlg.formID.activated.connect(self.list_repeatGroup)
        self.dlg.repeatGroup.activated.connect(self.list_submissions)
        self.dlg.attributeFilter.activated.connect(self.filter_items)
        self.dlg.filterValue.activated.connect(self.filter_Value)
        self.dlg.clearFilter.clicked.connect(self.clearFilter)
        self.dlg.odk_geometry.activated.connect(self.set_geometry)
        self.dlg.ignore_nogeom.toggled.connect(self.set_geometry)
        self.dlg.crs.setEnabled(True)
        self.dlg.crs.setCrs(QgsCoordinateReferenceSystem('EPSG:4326'))
        self.dlg.crs.crsChanged.connect(self.crs)
        self.dlg.save_csv.clicked.connect(self.saveCSV)
        self.dlg.load_to_canvas.clicked.connect(self.layerLoadQgis)
        self.dlg.Attachments.clicked.connect(self.download_images)
        self.dlg.attributeFilter.setEnabled(False)
        self.dlg.filterValue.setEnabled(False)
        self.dlg.filterExclude.setEnabled(False)
        self.dlg.Attachments.setEnabled(False) 
        self.dlg.save_csv.setEnabled(False)
        self.dlg.load_to_canvas.setEnabled(False) 
        pix=QPixmap(os.path.join(os.path.dirname(__file__), 'WTT.png'))
        self.dlg.WTT_label.setPixmap(pix)
        pix=QPixmap(os.path.join(os.path.dirname(__file__), 'icon.svg'))        
        self.dlg.QuODK_label.setPixmap(pix)
        self.dlg.QuODK_label_2.setPixmap(pix)
        self.dlg.closeWindow.clicked.connect(self.dlg.reject)

        self.dlg.filterExclude.clicked.connect(self.changeFilterState)
        
        #Load language labels
        self.language_EN()

        # show the dialog
        self.dlg.show()
        self.get_logins()            

        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
            
    # ====================================================================================================
    # LabelsTranslations: English
    def language_EN(self):

        self.dlg.label_odk_url.setText('ODK URL')
        self.dlg.label_odk_username.setText('Username')
        self.dlg.label_odk_pass.setText('Password')
        self.dlg.label_projectID.setText('Projects')
        self.dlg.label_daterange.setText('Get submissions from')
        self.dlg.label_formID.setText('ODK Form')
        self.dlg.label_repeatGroup.setText('Subset')
        self.dlg.label_attributeFilter.setText('Filter')
        self.dlg.label_odk_geometry.setText('Geometry')
        self.dlg.label_date_to.setText('to')
        self.dlg.help_label.setText('Help')
        self.dlg.ODK_connect.setText('Connect to ODK Central')
        self.dlg.remove_groups.setText('Remove group \nheadings')
        self.dlg.ignore_nogeom.setText('Include submissions \nwith no geometry')
        self.dlg.load_to_canvas.setText('Load layer to canvas')
        self.dlg.save_odk_pass.setText('Save password')
        self.dlg.load_all.setText('ignore dates')
        self.dlg.save_csv.setText('Save as CSV')
        #Dynamic labels / feedback within the dialog
#        self.dlg.QGIS_Layer_label.setText('Load ODK submissions to QGIS')
        self.tr_projectID = "-Select Project-"
        self.tr_formID = "-Select Form-"
        self.tr_repeatGroup = "-Select sub/repeat group-"
        self.tr_odk_geometry = "-Select Geometry-"
        self.tr_attributeFilter = "-Select Attribute-"
        self.tr_filterValues = "-Select Value-"
        self.tr_attachments_error = "Problem with attachments"
        self.tr_date_error = "Error: the left date should be earlier or equal"
        self.tr_no_data_in_range = "No data - try changing date range"
        self.tr_submissions_found = "Number of submissions found: "
        self.tr_layer_added = "Layer added - projected using "
        self.tr_general_error = "There is an error"
        self.tr_layer_error = "Error with this layer"
        self.tr_treewidget_head = ["Filename","Type","URL"]
        self.tr_mainForm = "Submissions(Main form)"
        self.tr_select_form_repeat = "Please select Form/Repeat/Geometry before loading"
        self.tr_check_server = "Please check server settings"
        self.tr_image_folder = "Select folder for images"
        self.tr_wait_images = "Please wait while the server collates images"
        self.tr_table_only = "Load table only (no geometry)"
        self.tr_filterExclude = "in/out"

        self.dlg.quodk_tab.setTabText(0,'Submissions')
        self.dlg.quodk_tab.setTabText(1,'Settings')

        self.dlg.help_text.setText('<h4>About</h4><p>This plugin works alongside an <strong>ODK Central Server</strong> (not Kobo / Ona etc). It allows you to load geo-located data gathered in ODK Collect forms as QGIS temporary layers, as well as download associated attachments. It is designed to allow you to incrementally download submissions (by selecting a date range of when data was sent from ODK Collect to the server. You can, with caution, opt to load all records - bear in mind this could take some time for large datasets with lots of attachments.</p><h4>Set up</h4><p>Ask the person responsible for managing your ODK Central server to provide you with log-in details (<strong>hint:</strong> it may be useful to set up a separate <a href="https://docs.getodk.org/central-users/">web-user on Central</a> with restricted access - e.g. Project Viewer). You can choose to save the password (stored in plain-text on your computer in the plug-in folder).</p><h4>Loading data</h4><p>Once you connect to your server you will get a list of ODK projects if appropriate, and then you can select the form you would like to download. If your form has repeat groups with location data you can select the repeat as well as the main form. You can load any form or repeat as a simple table if there is no location data (in case you want to link data in QGIS).</p><p>You can select a different Projection for the layer to fit with your project / location (e.g. OSGB grid). You can also download data as CSV.</p><strong>NOTE:</strong> By default QuODK only loads features with spatial data (point / line / polygon) so that they can be displayed in QGIS, but if you have some records that have no location data you can choose to include them and manual add relevant spatial data [once the layer is loaded, select the feature in the attribute table and then choose <i>Add part</i> in QGIS digitising toolbar] <h4>Attachments</h4><p>After you have selected the data you can download related attachments to a folder on your computer. This plugin also creates a project variable called @ODK_image_path so that you can view the attachments in the attribute form by setting the default path to this variable. Be aware that the plugin might freeze for a while when it loads the attachments form if you have lots of submissions. If you choose to download all the attachments listed it can take a while, needing high bandwidth - use with caution. </p><h4>Credits</h4><p>This plugin was inspired by FooODK which written in Swahili for WWF Tanzania by <strong>Cuthbert-Langen Mushi</strong>. Code refactoring, additional features and translations were implemented by Chris York at <a href="https://walking-the-talk.co.uk">Walking-the-Talk</a>. The plugin uses the ODK Central API to access the server and more functionality is planned (e.g. working with entities, and potentially deleting submissions)...</p><h4>Find out more about ODK</h4><p>ODK is an ecosystem of open source mobile data collection supported by a core development team and an active community.</p> <a href="https://getodk.org">ODK website</a></p><p><a href="https://forum.getodk.org">ODK forum</a> and <a href="https://docs.getodk.org">ODK documentation</a></p>')
    
    # ====================================================================================================
    def cw(self):
        self.close
    # ====================================================================================================    
    # Get credentials from file
    def get_logins(self):
        quodkinit = os.path.join(os.path.dirname(__file__), 'quodkinit.txt')
            
        if os.path.isfile(quodkinit):
            f = open(quodkinit, 'r')
            credentials = f.readlines()
            if credentials:
#                print(credentials)
                credentials_split = (credentials[0]).split(";")
                f.close()
            
                odk_url_toml = (credentials_split[0]).split("|")
                if odk_url_toml[0] == 'odk_url':
                    odk_url_tomlb = str(odk_url_toml[1])
                    self.dlg.odk_url.setText(odk_url_tomlb)
                
                odk_username_toml = (credentials_split[1]).split("|")
                if odk_username_toml[0] == 'odk_username':
                    odk_username_tomlb = str(odk_username_toml[1])
                    self.dlg.odk_username.setText(odk_username_tomlb)
                
                store_pass_toml = (credentials_split[2]).split("|")
                if store_pass_toml[0] == 'store_pass':
                    if store_pass_toml[1] =='False':
                        self.dlg.odk_pass_store_pass.setChecked(False)               
                
                odk_pass_toml = (credentials_split[3]).split("|")
                if odk_pass_toml[0] == 'odk_pass':
                    odk_pass_tomlb = str(odk_pass_toml[1])
                    self.dlg.odk_pass.setText(odk_pass_tomlb)
                
        if self.dlg.odk_url.text() == '' or self.dlg.odk_username.text() == '' or self.dlg.odk_pass.text() == '':
            self.dlg.msg.setText('Please check your server settings before proceeding')
            self.dlg.quodk_tab.setCurrentIndex(1)
                        
                
    # -----------------------------------------------------------------------------------------------
    # Store credentials to text file
    def set_logins(self):
        quodkinit = os.path.join(os.path.dirname(__file__), 'quodkinit.txt')
           
        odk_url = self.dlg.odk_url.text()
        odk_username = self.dlg.odk_username.text()
        
        if self.dlg.save_odk_pass.isChecked():
            store_pass = 'True'
            odk_pass = self.dlg.odk_pass.text()
        else:
            store_pass = 'False'
            odk_pass = ''
        odk_url_odk_username = "odk_url|" + str(odk_url) + ";" + "odk_username|" + str(odk_username)+ ";store_pass|" + str(store_pass)+ ";odk_pass|" + str(odk_pass)

        credentials = []
        if os.path.isfile(quodkinit):
            f = open(quodkinit, 'r')
            credentials = f.readlines()
            if credentials:
                credentials[0] = odk_url_odk_username
            f.close()
            
            f = open(quodkinit, "w")
            if credentials:
                f.writelines(credentials)
            f.close()

        if not os.path.isfile(quodkinit):
            f = open(quodkinit, "w")
            f.writelines(odk_url_odk_username)
            f.close()

    # ====================================================================================================
    session_token = ''
    selected_projectID = 0
    # ====================================================================================================
    # ====================================================================================================
    # Get ODK Central Projects
    def connectODK(self): #triggered by Connect button on either tab
        self.dlg.ODK_connect.setStyleSheet("background: orange")
        self.dlg.ODK_connect_2.setStyleSheet("background: orange")       
        self.dlg.projectID.clear()
        self.dlg.formID.clear()
        self.dlg.repeatGroup.clear()
        self.dlg.odk_geometry.clear()
        self.dlg.attributeFilter.clear()              
        global session_token
        session_token = self.get_session_token()
        if session_token:
            self.dlg.quodk_tab.setCurrentIndex(0)
            self.dlg.projectID.addItem(self.tr_projectID)
#            self.dlg.formID.addItem(self.tr_formID)   
#            self.dlg.repeatGroup.addItem(self.tr_repeatGroup)    
#            self.dlg.odk_geometry.addItem(self.tr_odk_geometry)   
#            self.dlg.attributeFilter.addItem(self.tr_attributeFilter)
            self.dlg.ODK_connect.setStyleSheet("background: DarkSeaGreen")
            self.dlg.ODK_connect_2.setStyleSheet("background: DarkSeaGreen")
            self.list_projects()
        

    
    # ====================================================================================================
    # ODK Central Session
    def get_session_token(self):
        global odk_url
        odk_url = self.dlg.odk_url.text()
        odk_username = self.dlg.odk_username.text()
        odk_pass = self.dlg.odk_pass.text()
        session_URL = (str(odk_url),"/v1/sessions")
        try:
            email_token_response = requests.post("".join(session_URL), data = json.dumps({"email": odk_username, "password": odk_pass}), headers = {"Content-Type": "application/json"},)        
            if email_token_response.status_code == 200:
                self.dlg.status.setStyleSheet("color: DarkSeaGreen")
                #print(email_token_response.json()["token"])
                return email_token_response.json()["token"]

            else:
                self.dlg.msg.setText(self.tr_check_server)
                self.dlg.msg.setStyleSheet("background: red")
                self.dlg.ODK_connect_2.setStyleSheet("background: red")
                self.dlg.ODK_connect.setStyleSheet("background: red")
                self.dlg.quodk_tab.setCurrentIndex(1)
        except:
            self.dlg.msg.setText('Please check this a valid URL')
            self.dlg.ODK_connect.setStyleSheet("background: red")
            self.dlg.ODK_connect_2.setStyleSheet("background: red")
            self.dlg.quodk_tab.setCurrentIndex(1)
    # ====================================================================================================
    #List all Projects
    def list_projects(self): #triggered after Connecting to Central
        projects_url = (str(odk_url),"/v1/projects/")
        projects_response = requests.get("".join(projects_url),headers={"Authorization": "Bearer " + session_token},)
        projects = {}
        
        if projects_response.status_code == 200:
            self.set_logins()
            self.dlg.quodk_tab.setCurrentIndex(0) # set the form to show submissions tab)
            for project in projects_response.json():
                self.dlg.projectID.addItem(str(project["id"]) + '|' + project["name"])
            if self.dlg.projectID.count() == 2:
                self.dlg.projectID.setCurrentIndex(1)
                self.list_forms()
        return None
           
    # ====================================================================================================
    #List all Forms
    def list_forms(self): # triggered by Projects combo box
        #(re)set combo boxes to blank / default text
        self.dlg.formID.clear()
        self.dlg.repeatGroup.clear()
        self.dlg.odk_geometry.clear()
        self.dlg.attributeFilter.clear()
        self.dlg.formID.addItem(self.tr_formID)   
#        self.dlg.repeatGroup.addItem(self.tr_repeatGroup)   
#        self.dlg.odk_geometry.addItem(self.tr_odk_geometry)   
#        self.dlg.attributeFilter.addItem(self.tr_attributeFilter)
        #form list with index 0 as 'select form'
        self.xmlFormId = []
        self.xmlFormId.append(str(self.tr_formID))
                
        global selected_projectID
        selected_projectID = str(self.dlg.projectID.currentText()).split('|')[0]
        global form_url
        form_url = (str(odk_url),"/v1/projects/",str(selected_projectID),"/forms/")
        form_url = "".join(form_url)
        self.dlg.progressBar.setRange(0,0)
        self.dlg.progressBar.setTextVisible(False)
        form_response = requests.get(str(form_url), headers = {"Authorization": "Bearer " + session_token},)

        if form_response.status_code == 200:
            for formID in form_response.json():
                self.xmlFormId.append(formID["xmlFormId"])
                self.dlg.formID.addItem(str(formID["name"]))
        self.dlg.progressBar.setRange(0,100)

        return None

    # ====================================================================================================
    #List all repeat groups (if any) within the selected form and get the submission id table
    def list_repeatGroup(self): # triggered by select form combo box
        #(re)set dependent combo-boxes to clear and add default repeatGroup entry
        #global keyID         #master set of submissions to compare 
        self.keyID = []
        self.dlg.repeatGroup.clear()
        self.dlg.odk_geometry.clear()
        self.dlg.attributeFilter.clear()
        self.repeatGroups = ""
        self.dlg.repeatGroup.addItem(self.tr_repeatGroup)           
        iformID = self.xmlFormId[self.dlg.formID.currentIndex()]
        #DateStart = self.dlg.DateStart.date()
        #DateEnd = self.dlg.DateEnd.date()
        #sDate = DateStart.toPyDate()
        #eDate = DateEnd.toPyDate()

        #Get repeats within selected form
        self.dlg.progressBar.setRange(0,0)
        self.dlg.progressBar.setTextVisible(False)
        svc_url = (str(form_url),str(iformID),".svc")
        svc_Response = requests.get("".join(svc_url), headers={"Authorization": "Bearer " + session_token},)

        if svc_Response.status_code == 200:
            subFormID = svc_Response.json()['value']
            for sfid in subFormID:
                if sfid["url"] == "Submissions":
                    self.dlg.repeatGroup.addItem(self.tr_mainForm)
                else:
                    self.dlg.repeatGroup.addItem(sfid["url"])
                    self.repeatGroups = self.repeatGroups + str(sfid['url'])+"; "
#            self.get_submissions()
            if self.dlg.repeatGroup.count() == 2:
                self.dlg.filterValue.setEnabled(True)
                self.dlg.attributeFilter.setEnabled(True)
            self.dlg.repeatGroup.setCurrentIndex(1)
            self.list_submissions()
        self.dlg.progressBar.setRange(0,100)

#        except:
#            self.dlg.msg.setText(self.tr_general_error)
#            self.dlg.msg.setStyleSheet("background: red")
            
        return None

            #-------------------------------------------------------------------------------------------------
    def get_Response(self,filter_url):
        self.dlg.progressBar.setRange(0,0)
        self.dlg.progressBar.setTextVisible(False)
        odk_Response = requests.get("".join(filter_url), headers={"Authorization": "Bearer " + session_token},)
        if odk_Response.status_code == 200:            
            odkJson = odk_Response.json()['value']
            #global dataframe for the (normalised) Json data retrieved
            df_ODK = pd.json_normalize(odkJson)      #create the 'master' dataframe
            df_ODK = df_ODK.assign(geom_from_ODK=None)
            #update column headings and identfy geometry column(s)
            self.dlg.odk_geometry.clear()
            self.dlg.odk_geometry.addItem(self.tr_odk_geometry)  
            self.dlg.odk_geometry.addItem(self.tr_table_only) 
            self.dlg.odk_geometry.setCurrentIndex(0)
            geomKeys = ["Point","LineString","Polygon"] # possible geometry types
            geomName = ""
            geomCol = list()
            headers = list(df_ODK) # get a list of the columns in the dataframe
            headings = list()
            col_number = 0
            #loop through column names and update 
            for header in headers : 
                if header.find('.') >-1:
                    # look for geometry field (name, type, accuracy) and replace column name
    #                    geomType = df_ODK.loc[0,header]
    #                    print(header, geomType)
                    #print(header, df_ODK.loc[0,header])                   
                    header = header.replace('.properties.','-')
                    header = header.replace('.coordinates','-coordinates')
                    df_ODK.rename(columns={df_ODK.columns[col_number]: header}, inplace=True)
                    notnullindex = df_ODK[header].first_valid_index()
                    #print(header, notnullindex)
                    if notnullindex == None:
                        notnullindex = 0

                    if df_ODK.loc[notnullindex,header] in (geomKeys):
                        geomType = df_ODK.loc[notnullindex,header]

                    #add to list of possible geometry for combo box
                        geomName = str(header.rsplit('.',1)[0])
                        geomItem = str(geomName)+'--->'+str(geomType)
                        self.dlg.odk_geometry.addItem(str(geomItem))
    #                    if geomName in str(header):
                        
                        #header = header.replace('.','-')
    #                        print(geomCol, geomName, geomType, header)
                    

    #                    if self.dlg.remove_groups.isChecked():
    #                       header = header.split('.')[-1]
    #                   else:
    #                       header = header.rsplit('.',1)[-0]

                header = header.replace('__Submissions-id','PARENT_KEY')
                header = header.replace('__id','KEY')
                headings.append(header)
                #print(header)
                df_ODK.rename(columns={df_ODK.columns[col_number]: header}, inplace=True)
                if df_ODK[header].dtype != 'float64':
                    self.dlg.attributeFilter.addItem(header)
                col_number +=1
            if self.dlg.odk_geometry.count() <= 3:
                self.dlg.odk_geometry.setCurrentIndex(self.dlg.odk_geometry.count()-1)
                self.dlg.save_csv.setEnabled(True)
                self.dlg.load_to_canvas.setEnabled(True)  
                self.dlg.Attachments.setEnabled(True)
    #            uniqueGeom = set(geomCol)           
    #            for geomKey in uniqueGeom
    #                self.dlg.odk_geometry.addItem(str(geomKey)
            self.dlg.progressBar.setRange(0,100)
            return df_ODK
        else:
            self.dlg.msg.setText(self.tr_check_server+ str(odk_Response.status_code))
            self.dlg.progressBar.setRange(0,100)

        

    #List all Forms submissions
    def list_submissions(self): # triggered by repeatGroup combo or if there are no repeats in the form
        #(re)set dependent combo-boxes and set up default values
        #self.dlg.attributeFilter.setEnabled(True)
        #global self.df_repeat
        self.dlg.progressBar.setRange(0,0)
        self.dlg.progressBar.setTextVisible(False)
        self.dlg.attributeFilter.clear()     
        self.dlg.attributeFilter.addItem(self.tr_attributeFilter) 
        iformID = self.xmlFormId[self.dlg.formID.currentIndex()]
        sel_repeatGroup = self.dlg.repeatGroup.currentText()
        DateStart = self.dlg.DateStart.date()
        DateEnd = self.dlg.DateEnd.date()
        sDate = DateStart.toPyDate()
        eDate = DateEnd.toPyDate()        
        if  sDate > eDate:  #check dates are a real range
            self.dlg.msg.setText(self.tr_date_error)
            
        else:   #create global date range filter
            
            global filterDateS
            global filterDateE
            filterDateS = str("__system/submissionDate ge " + str(sDate)+'T00:00:00.00Z')
            filterDateE = str("__system/submissionDate le " + str(eDate)+'T23:59:59.99Z')

        if sel_repeatGroup == self.tr_mainForm: # fetch main form
            self.keyLevel = "KEY"
            if self.dlg.load_all.isChecked():
                filter_url = (form_url,str(iformID),".svc/Submissions")
            else:
                filter_url = (form_url,str(iformID),".svc/Submissions?$filter=",filterDateS," and ",filterDateE)
            self.df_submissions = self.get_Response(filter_url)
            submissionsTotal = self.df_submissions.shape[0]
            self.dlg.attributeFilter.setEnabled(True)
            self.dlg.filterExclude.setEnabled(True)
            self.dlg.filterExclude.setCheckable(True)
#            self.dlg.filterExclude.isChecked(True)
            self.changeFilterState()
            try:
                self.AttachmentsTotal = self.df_submissions['__system.attachmentsPresent'].sum()
            except:
                self.AttachmentsTotal = 0
            if submissionsTotal == 0:   #check whether there are any submissions in the date range
                self.dlg.msg.setStyleSheet("background: orange")
                self.dlg.msg.setText(self.tr_submissions_found + str(0))
            else:
                self.keyID = list(self.df_submissions['KEY'])
                self.dlg.msg.setStyleSheet("background: cyan")
                self.dlg.msg.setText('')
                self.updateTable(self.df_submissions) #load the dataframe to the Qtable

        else: #  or replace dataframe with rows from repeat within the date range ($root/Submissions)
            self.keyLevel = "PARENT_KEY"
            if self.dlg.load_all.isChecked():
                filter_url = (form_url,str(iformID),".svc/",str(sel_repeatGroup))
            else:
                filter_url = (form_url,str(iformID),".svc/",str(sel_repeatGroup),"?$filter=$root/Submissions/",filterDateS," and $root/Submissions/",filterDateE)
            self.df_repeat = self.get_Response(filter_url)
            #print(self.df_repeat.head())
            self.dlg.filterValue.setEnabled(False)
            self.dlg.attributeFilter.setEnabled(False)
            self.df_repeat = self.df_repeat[self.df_repeat[self.keyLevel].isin(self.keyID)]
            #print(self.keyLevel, self.keyID,self.df_repeat.head())
            self.updateTable(self.df_repeat)    #load the dataframe to the Qtable
#        self.dlg.save_csv.setEnabled(True)
#        self.dlg.load_to_canvas.setEnabled(True)  
        self.dlg.Attachments.setEnabled(True)
        self.dlg.ignore_nogeom.setEnabled(True)
        self.dlg.remove_groups.setEnabled(True)
        self.dlg.progressBar.setRange(0,100)
#        return None

    # adapt the received column headings and identify geometry column(s)

    # ====================================================================================================
    def filter_items(self): # triggered by attributeFilter combo
        
        attributeFilter = self.dlg.attributeFilter.currentText()
        #self.dlg.clearFilter.setEnabled(True)
        if attributeFilter != self.tr_attributeFilter:
            uniqueValues = self.df_submissions[attributeFilter].unique().tolist()
            #print(uniqueValues)
            self.dlg.filterValue.setEnabled(True)
            self.dlg.filterValue.clear()
            self.dlg.filterValue.addItem(self.tr_filterValues)
            for u in uniqueValues:
                self.dlg.filterValue.addItem(u)

    
    # ====================================================================================================
    
    def filter_Value(self): #triggered by filterValue combo - only active for main form - runs straight to set_geometry

        self.dlg.clearFilter.setEnabled(True)
        self.set_geometry()

    # ====================================================================================================
    def clearFilter(self):
        self.dlg.clearFilter.setEnabled(False)
        self.dlg.attributeFilter.setCurrentIndex(0)
        self.dlg.filterValue.clear()
        self.set_geometry()

    # ====================================================================================================
    def changeFilterState(self):
        #isChecked
        if self.dlg.filterExclude.isChecked():
            self.dlg.filterExclude.setText("Exclude")
        else:
            self.dlg.filterExclude.setText("Include")
        self.set_geometry()
        
    # ====================================================================================================
 
    def set_geometry(self): #triggered by geometry combo box AND when Filter is selected
            if self.keyLevel == "KEY":     #check if main form and get any filter
                filterValue = str(self.dlg.filterValue.currentText())
                attributeFilter = str(self.dlg.attributeFilter.currentText())
                if self.dlg.filterValue.currentIndex() > 0:
                    if self.dlg.filterExclude.isChecked():
                        df_geomfilter = self.df_submissions[self.df_submissions[attributeFilter] != filterValue]
                    else:
                        df_geomfilter = self.df_submissions[self.df_submissions[attributeFilter] == filterValue]
                else:
                    df_geomfilter = self.df_submissions                    
            else:   #use repeat dataframe
                df_geomfilter = self.df_repeat
                
            if self.dlg.odk_geometry.currentIndex() >1: 
                geomType = self.dlg.odk_geometry.currentText()
                geomCol = str(str(geomType).split("--->")[0])+'-coordinates'
                if self.dlg.ignore_nogeom.isChecked():
                    pass
                else:
                    df_geomfilter =df_geomfilter.dropna(subset=[geomCol])
                #print(geomCol)

            self.updateTable(df_geomfilter)
            if self.dlg.odk_geometry.currentIndex() >0:
                self.dlg.save_csv.setEnabled(True)
                self.dlg.load_to_canvas.setEnabled(True)  
                self.dlg.Attachments.setEnabled(True)
            else:
                self.dlg.save_csv.setEnabled(False)
                self.dlg.load_to_canvas.setEnabled(False)  
                self.dlg.Attachments.setEnabled(False)            

    # ====================================================================================================
    # update dataTable after combo box selections
    def updateTable(self, df_table):
        self.dlg.dataTable.clear()
        headings = list(df_table)
        
        self.dlg.dataTable.setRowCount(df_table.shape[0])
        self.dlg.dataTable.setColumnCount(df_table.shape[1])
        self.dlg.dataTable.setHorizontalHeaderLabels(headings)        
        self.dlg.dataTable.resizeColumnsToContents()
        # convert dataframe to array before populating table
        df_array = df_table.values
        for row in range(df_table.shape[0]):
            for col in range(df_table.shape[1]):
                self.dlg.dataTable.setItem(row, col, QTableWidgetItem(str(df_array[row,col])))
        #self.filterID
        if self.keyLevel == 'KEY':
            self.filterID = list(df_table['KEY'])
            self.AttachmentsTotal = df_table['__system.attachmentsPresent'].sum()
        #print (self.filterID)

        self.dlg.msg.setText(self.tr_submissions_found + str(df_table.shape[0])+" ("+str(self.AttachmentsTotal)+" attachments)\nSubsets (ODK_repeats): "+str(self.repeatGroups))
        return None

    # ====================================================================================================
    def onDateChanged(self):
        if self.dlg.formID.currentIndex() > 0:
            self.list_submissions()
        else:
            self.dlg.formID.setCurrentIndex(0)
            self.dlg.repeatGroup.setCurrentIndex(0)
            self.dlg.odk_geometry.setCurrentIndex(0)
            self.dlg.attributeFilter.setCurrentIndex(0)

    # ====================================================================================================
    def crs(self):

        crsId = str(self.dlg.crs.CrsOption())
        #self.dlg.msg.setText(str(self.dlg.crs.crs()))
    
    # ====================================================================================================    
    # Load layer with all attributes using normalised json as dataframe
    def layerLoadQgis(self):
        self.dlg.progressBar.setRange(0,0)
        self.dlg.progressBar.setTextVisible(False)
        if self.keyLevel == "KEY":     
            df_layer = self.df_submissions
        else:
            df_layer = self.df_repeat
        # Remove rows that have been filtered out and reset the index
        df_layer = df_layer[df_layer[self.keyLevel].isin(self.filterID)]
        df_layer.index = range(len(df_layer.index))
        #print (self.filterID)
        #print(df_layer.head())
        if self.dlg.odk_geometry.currentText() == self.tr_odk_geometry:
            self.dlg.msg.setText(self.tr_select_form_repeat)
            self.dlg.msg.setStyleSheet("background: orange")
        else: 
            #iformID = self.xmlFormId[self.dlg.formID.currentIndex()]
            FormName = self.dlg.formID.currentText().split('|')[0]
            sel_repeatGroup = self.dlg.repeatGroup.currentText()
            filterValue = str(self.dlg.filterValue.currentText())
            attributeFilter = self.dlg.attributeFilter.currentText()
            if sel_repeatGroup == self.tr_mainForm:
                keyLevel = 'KEY'
            else:
                keyLevel = 'PARENT_KEY'

            geomType = self.dlg.odk_geometry.currentText()
            if geomType == self.tr_table_only:
                layerGeom = "NoGeometry"
                geomName = ""
                geomCol = "geom_from_ODK"
            else:
                layerGeom = str(str(geomType).split("--->")[-1:][0])
                geomName = str(str(geomType).split("--->")[0])
                geomCol = str(geomName + '-coordinates')
                if self.dlg.ignore_nogeom.isChecked():
                    df_layer_all = df_layer
                df_layer = df_layer.dropna(subset=[geomCol])
                df_layer.index = range(len(df_layer.index))
            # Create QgsVectorLayer with appropriate geometry (or just a table if there is no geometry)
            #try:
            #if str(layerGeom) == "NoGeometry": 
            #    LayerType = "NoGeometry"
            #else: 
            crs = self.dlg.crs.crs()
            projection = QgsCoordinateReferenceSystem.authid(crs)
            LayerType = str(str(layerGeom)+"?crs=" + str(projection))
            
            if sel_repeatGroup == self.tr_mainForm:
                result = 'TMP_'+FormName
            else:
                result = 'TMP_' + FormName+'_'+sel_repeatGroup.split(".")[1]
            temp = QgsVectorLayer(LayerType,result,"memory")
            temp_data = temp.dataProvider()
            temp.startEditing()
            # Create  fields in dataProvider - Qvariant type according to dtype in dataframe
            headers = list(df_layer)
            col_number = 0
            for header in headers : 
                #print(header)
                datatype= df_layer[header].dtype

                #ensure the fields are the correct QGIS type to receive the data (string, int or double)
                if datatype == 'object':
                    temp_data.addAttributes([QgsField(header,QVariant.String)])
                if datatype == 'int64':
                    temp_data.addAttributes([QgsField(header,QVariant.Int)])
                elif datatype == 'float64':
                    temp_data.addAttributes([QgsField(header,QVariant.Double, 'double', 20, 3)]) #length 20, precision 3
                else:
                    temp_data.addAttributes([QgsField(header,QVariant.String)])
                col_number+=1   
            temp.updateFields()

            # Populate the layer by iterating through the dataframe
            if self.dlg.ignore_nogeom.isChecked():
                df_layer = df_layer_all
            headers = list(df_layer) 
            self.construct_geometry(df_layer,layerGeom, geomCol)
            # Add features with the given geometry

            for i,row in df_layer.iterrows():
                if str(layerGeom) == "NoGeometry": 
                    geom =""
                else:
                    geom = df_layer.loc[i, 'geom_from_ODK']
                #print(geom)
                f = QgsFeature()
                #f.setGeometry(QgsGeometry.fromWkt(geom)) 
                #this allows transformation to chosen CRS!!!
                base_geom = QgsGeometry.fromWkt(geom)
                sourceCrs = QgsCoordinateReferenceSystem("EPSG:4326")
                destCrs = crs
                tr = QgsCoordinateTransform(sourceCrs, destCrs, QgsProject.instance())
                if str(layerGeom) == "NoGeometry": 
                    pass
                else:
                    base_geom.transform(tr)
                #print(base_geom)
                f.setGeometry(base_geom)
                temp_data.addFeatures([f])
                temp.commitChanges()
                temp.updateFields()
                temp.updateExtents()
            
            # Populate the attribute table for each feature
            features = temp.getFeatures()
            count=0
            headers = list(df_layer)
            for feature in features:
                for header in headers:
                    with edit(temp):
                        datatype= df_layer[header].dtype
                        #print(count,header, datatype)
                        #insert feature with the appropriate data type
                        attributeValue = df_layer.loc[count,header]
                        if attributeValue == None:
                            pass
                        else:
                            if datatype == 'object':
                                attributeValue = str(attributeValue)
                            else:
                                if isnan(attributeValue):
                                    attributeValue = None
                                else:
                                    attributeValue = float(attributeValue)
                        #print(attributeValue,datatype)
                        feature[header] = attributeValue
                        temp.updateFeature(feature)
                count+=1
            temp.commitChanges()

            QgsProject.instance().addMapLayer(temp)   
            self.dlg.msg.setText(self.tr_layer_added + projection)
            self.dlg.msg.setStyleSheet("background: DarkSeaGreen")
            self.dlg.progressBar.setRange(0,100)
 #           except:
 #               self.dlg.msg.setText(self.tr_layer_error) 
 #               self.dlg.msg.setStyleSheet("background: red")
#        else:
#            self.dlg.msg.setText(self.tr_no_data_in_range)
#            self.dlg.msg.setStyleSheet("background: red")

    #-----------------------------------------------------------------------------------------------------
    def download_images(self):   #download the filtered list of images from the main form                 

        df_attach = self.df_submissions
        odk_username = self.dlg.odk_username.text()
        odk_pass = self.dlg.odk_pass.text()
        formID = self.xmlFormId[self.dlg.formID.currentIndex()]
        df_attach = df_attach[df_attach['KEY'].isin(self.filterID)]
        count = 0
        #--------------------------------------------------------
        aFolder = QFileDialog.getExistingDirectory(None, self.tr_image_folder)
        if aFolder:
            self.dlg.progressBar.setRange(0,100)
            self.dlg.progressBar.setTextVisible(True)
            #iterate through the instances (which may be filtered) and collate the attachments
            try:
                for i,iData in df_attach.iterrows():  
                    InstanceID = df_attach.loc[i, 'meta.instanceID']
                    attach_url = (form_url,formID,"/submissions/",str(InstanceID),"/attachments")
                    attach_url = "".join(attach_url)
                    attach_url_Response = requests.get(attach_url, headers={"Authorization": "Bearer " + session_token}, )
                    if attach_url_Response.status_code == 200:
                        #set up a dataframe for the attachments in each instance nd then iterate through, downloading as you go!
                        attachJson = attach_url_Response.json()
                        df_attachments = pd.json_normalize(attachJson)
                        for i,iData in df_attachments.iterrows():
                            progress = int((count+1)/ self.AttachmentsTotal*100)
                            self.dlg.progressBar.setValue(progress)
                            filename = df_attachments.loc[i,'name']
                            source_url = attach_url+'/'+ filename
                            destination = aFolder+'/'+ filename
                            streamImage = requests.get(source_url, auth = (odk_username,odk_pass), stream=True, allow_redirects=True)
                            streamImageHead = streamImage.headers.get('content-type')
                            f = open(destination, 'wb')
                            f.write(streamImage.content)
                            f.close()
                            count +=1


                self.dlg.msg.setText(str(self.AttachmentsTotal)+' downloaded to '+ aFolder)
                self.dlg.msg.setStyleSheet("background: DarkSeaGreen")
                QgsExpressionContextUtils.setProjectVariable(QgsProject.instance(), 'ODK_image_path',aFolder)
              # Add a project variable called Image - for attribute form viewing of images
                #if self.dlg.project_variable.setChecked(True):
                #QgsExpressionContextUtils.setProjectVariable('Images_Folder',aFolder)
            
            
            except:
                self.dlg.msg.setText(self.tr_attachments_error)
                self.dlg.msg.setStyleSheet("background: red")

    #-----------------------------------------------------------------------------------------------------
    def saveCSV(self):
        if self.dlg.odk_geometry.currentText() == self.tr_odk_geometry:
            self.dlg.msg.setText(self.tr_select_form_repeat)
            self.dlg.msg.setStyleSheet("background: orange")
        else: 
            self.dlg.progressBar.setRange(0,0)
            self.dlg.progressBar.setTextVisible(False)
            iformID = self.xmlFormId[self.dlg.formID.currentIndex()]
            csvFilename, fileType = QFileDialog.getSaveFileName(None,'Select filename for ' + iformID,iformID,"*.csv")  
            #print(csvFilename, fileType)
            if csvFilename:
                if self.keyLevel == "KEY":
                    df_layer = self.df_submissions
                else:
                    df_layer = self.df_repeat
                # Remove rows that have been filtered out
                df_layer = df_layer[df_layer['KEY'].isin(self.filterID)]
                #Generate geometry and file format to load into canvas
                geomType = self.dlg.odk_geometry.currentText()
                projection = "EPSG:4326"            
                if geomType == self.tr_table_only:
                    layerGeom = "NoGeometry"
                    projection = "table only - no projection"
                    #geomCol = "geom_from_ODK"
                    uri = 'file:///{}?delimiter=,'.format(csvFilename)
                else:
                    layerGeom = str(str(geomType).split("--->")[-1:][0])
                    geomName = str(str(geomType).split("--->")[0])
                    geomCol = str(geomName + '-coordinates')
                    uri ='%s?delimiter=%s&crs=%s&wktField=%s' % (str("file:///"+csvFilename), ",", projection, "geom_from_ODK")
                    self.construct_geometry(df_layer,layerGeom, geomCol)
                    
                csvName = os.path.splitext(os.path.basename(csvFilename))[0]
                df_layer.to_csv(str(csvFilename))  

                #print(csvName, uri)
                NewLayer = QgsVectorLayer(uri, csvName, 'delimitedtext')         
                QgsProject.instance().addMapLayer(NewLayer) 
                self.dlg.msg.setText(self.tr_layer_added + projection)
                self.dlg.msg.setStyleSheet("background: DarkSeaGreen")
                                            
            else:
                self.dlg.msg.setText(self.tr_no_data_in_range)
                self.dlg.msg.setStyleSheet("background: red")

        self.dlg.progressBar.setRange(0,100)
#        return None        

    # ====================================================================================================
    
    def construct_geometry(self,df_layer,layerGeom,geomCol):
        for i,iData in df_layer.iterrows():  
            atts = dict(iData)
            iValues = df_layer.loc[i, geomCol]
            #Convert to Point WKT 
            if str(layerGeom) == "Point":                    
                #iValues = df_layer.loc[i, geomCol]
                if type(iValues) is list:
                    XYZ = " ".join(map(str, iValues))
                    self.WKT = ("POINT (" + XYZ +")")  
                else:
                    self.WKT = ""

            #--------------------------------------------------------
            #Convert to LineString WKT                
            if str(layerGeom) == "LineString":
                #iValues = df_layer.loc[i, geomCol] 
                if type(iValues) is list:                        
                    c = ""
                    for a in iValues:
                        b = ("".join(str(a))[1:][:-1]).replace(",", "")
                        c = c + ", " + b
                    XYZ = c[1:]                                
                    self.WKT = ("LINESTRING (" + XYZ +")")
                else:
                    self.WKT = ""
            #--------------------------------------------------------
            #Convert to Polygon WKT
            if  str(layerGeom)  == "Polygon":                           
                #iValues = df_layer.loc[i, geomCol] 
                #print(iValues)
                if type(iValues) is list:  
                    c = ""
                    for a in iValues[0]:
                        b = ("".join(str(a))[1:][:-1]).replace(",", "")
                        c = c + ", " + b
                    XYZ = c[1:]
                    self.WKT = ("POLYGON ((" + XYZ + "))")
                else:
                    self.WKT = ""
            #--------------------------------------------------------
            #Convert to table only           
            if str(layerGeom) == "NoGeometry": 
                self.WKT = "NoGeometry"
                
            #Add geometry to dataframe
            df_layer.loc[i, 'geom_from_ODK'] = str(self.WKT)
        return df_layer
        
